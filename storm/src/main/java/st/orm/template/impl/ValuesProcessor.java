/*
 * Copyright 2024 - 2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package st.orm.template.impl;

import jakarta.annotation.Nonnull;
import st.orm.BindVars;
import st.orm.template.SqlTemplateException;
import st.orm.template.impl.Elements.Values;

import java.util.ArrayList;
import java.util.List;

import static java.util.stream.Collectors.joining;
import static java.util.stream.IntStream.range;

/**
 * A processor for a values element of a template.
 */
final class ValuesProcessor implements ElementProcessor<Values> {

    private final SqlTemplateProcessor templateProcessor;
    private final ModelBuilder modelBuilder;
    private final PrimaryTable primaryTable;

    ValuesProcessor(@Nonnull SqlTemplateProcessor templateProcessor) {
        this.templateProcessor = templateProcessor;
        this.modelBuilder = templateProcessor.modelBuilder();
        this.primaryTable = templateProcessor.primaryTable();
    }

    /**
     * Process a values element of a template.
     *
     * @param values the values element to process.
     * @return the result of processing the element.
     * @throws SqlTemplateException if the template does not comply to the specification.
     */
    @Override
    public ElementResult process(@Nonnull Values values) throws SqlTemplateException {
        if (primaryTable == null) {
            throw new SqlTemplateException("Primary entity not found.");
        }
        if (values.records() != null) {
            return getRecordsString(values.records(), values.ignoreAutoGenerate());
        }
        if (values.bindVars() != null) {
            return getBindVarsString(values.bindVars(), values.ignoreAutoGenerate());
        }
        throw new SqlTemplateException("No values found for Values.");
    }

    /**
     * Returns the SQL string for the specified records.
     *
     * @param records the records to process.
     * @param ignoreAutoGenerate whether to ignore the auto-generated flag.
     * @return the SQL string for the specified record.
     * @throws SqlTemplateException if the template does not comply to the specification.
     */
    private ElementResult getRecordsString(@Nonnull Iterable<? extends Record> records, boolean ignoreAutoGenerate) throws SqlTemplateException {
        var table = primaryTable.table();
        List<String> args = new ArrayList<>();
        for (var record : records) {
            if (record == null) {
                throw new SqlTemplateException("Record is null.");
            }
            if (!table.isInstance(record)) {
                throw new SqlTemplateException(STR."Record \{record.getClass().getSimpleName()} does not match entity \{table.getSimpleName()}.");
            }
            var map = ModelMapper.of(modelBuilder.build(record, false))
                    .map(record, column -> (ignoreAutoGenerate || !column.autoGenerated()) && column.insertable())
                    .sequencedValues();
            if (map.isEmpty()) {
                throw new SqlTemplateException("No values found for Insert.");
            }
            List<String> placeholders = new ArrayList<>();
            for (var o : map) {
                placeholders.add(templateProcessor.bindParameter(o));
            }
            args.add(STR."(\{String.join(", ", placeholders)})");
            args.add(", ");
        }
        if (!args.isEmpty()) {
            args.removeLast();
        }
        return new ElementResult(String.join("", args));
    }

    /**
     * Returns the SQL string for the specified bindVars.
     *
     * @param bindVars the bindVars to process.
     * @param ignoreAutoGenerate whether to ignore the auto-generated flag.
     * @return the SQL string for the specified bindVars.
     * @throws SqlTemplateException if the template does not comply to the specification.
     */
    private ElementResult getBindVarsString(@Nonnull BindVars bindVars, boolean ignoreAutoGenerate) throws SqlTemplateException {
        if (bindVars instanceof BindVarsImpl vars) {
            var bindsVarCount = (int) modelBuilder.build(primaryTable.table(), false)
                    .columns().stream()
                    .filter(column -> (ignoreAutoGenerate || !column.autoGenerated()) && column.insertable())
                    .count();
            var parameterFactory = templateProcessor.setBindVars(vars, bindsVarCount);
            vars.addParameterExtractor(record -> {
                try {
                    ModelMapper.of(modelBuilder.build(record, false))
                            .map(record, column -> !column.autoGenerated() && column.insertable())
                            .sequencedValues()
                            .forEach(parameterFactory::bind);
                    return parameterFactory.getParameters();
                } catch (SqlTemplateException ex) {
                    throw new UncheckedSqlTemplateException(ex);
                }
            });
            String bindVarsString = range(0, bindsVarCount).mapToObj(_ -> "?").collect(joining(", "));
            return new ElementResult(STR."(\{bindVarsString})");
        }
        throw new SqlTemplateException("Unsupported BindVars type.");
    }
}
