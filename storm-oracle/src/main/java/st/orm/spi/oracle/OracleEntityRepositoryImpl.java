/*
 * Copyright 2024 - 2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package st.orm.spi.oracle;

import jakarta.annotation.Nonnull;
import st.orm.Data;
import st.orm.Metamodel;
import st.orm.core.repository.EntityRepository;
import st.orm.core.template.PreparedQuery;
import st.orm.core.repository.impl.EntityRepositoryImpl;
import st.orm.core.template.Column;
import st.orm.core.template.Model;
import st.orm.core.template.ORMTemplate;
import st.orm.core.template.SqlTemplateException;
import st.orm.core.template.TemplateString;
import st.orm.core.template.impl.LazySupplier;
import st.orm.BindVars;
import st.orm.Entity;
import st.orm.PersistenceException;

import java.math.BigInteger;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.function.Function.identity;
import static java.util.function.Predicate.not;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.partitioningBy;
import static st.orm.GenerationStrategy.IDENTITY;
import static st.orm.GenerationStrategy.SEQUENCE;
import static st.orm.core.repository.impl.DirtySupport.getMaxShapes;
import static st.orm.core.repository.impl.StreamSupport.partitioned;
import static st.orm.core.template.Templates.table;
import static st.orm.core.template.Templates.bindVar;
import static st.orm.core.template.SqlInterceptor.intercept;
import static st.orm.core.template.TemplateString.combine;
import static st.orm.core.template.TemplateString.raw;
import static st.orm.core.template.TemplateString.wrap;
import static st.orm.core.template.impl.StringTemplates.flatten;

/**
 * Implementation of {@link EntityRepository} for Oracle.
 */
public class OracleEntityRepositoryImpl<E extends Entity<ID>, ID> extends EntityRepositoryImpl<E, ID> {

    public OracleEntityRepositoryImpl(@Nonnull ORMTemplate ormTemplate, @Nonnull Model<E, ID> model) {
        super(ormTemplate, model);
    }

    private String getVersionString(@Nonnull Column column) {
        String columnName = column.qualifiedName(ormTemplate.dialect());
        String updateExpression = switch (column.type()) {
            case Class<?> c when Integer.TYPE.isAssignableFrom(c)
                    || Long.TYPE.isAssignableFrom(c)
                    || Integer.class.isAssignableFrom(c)
                    || Long.class.isAssignableFrom(c)
                    || BigInteger.class.isAssignableFrom(c) -> "src.%s + 1".formatted(columnName);
            case Class<?> c when Instant.class.isAssignableFrom(c)
                    || Date.class.isAssignableFrom(c)
                    || Calendar.class.isAssignableFrom(c)
                    || Timestamp.class.isAssignableFrom(c) -> "SYSTIMESTAMP";
            default ->
                    throw new PersistenceException("Unsupported version type: %s.".formatted(column.type().getSimpleName()));
        };
        return "t.%s = %s".formatted(columnName, updateExpression);
    }

    private TemplateString mergeSelect(@Nonnull E entity) {
        assert !isAutoGeneratedPrimaryKey();
        var dialect = ormTemplate.dialect();
        var duplicates = new HashSet<>();   // CompoundPks may also have their columns included as stand-alone fields. Only include them once.
        try {
            var mapped = model.values(entity, column -> true);
            return mapped.entrySet()
                    .stream()
                    .filter(entry -> duplicates.add(entry.getKey().name()))
                    .map(entry -> {
                        Object value = entry.getValue();
                        if (entry.getKey().primaryKey()) {
                            //noinspection unchecked
                            if (model.isDefaultPrimaryKey((ID) value)) {
                                value = null;   // Always pass NULL to force a mismatch.
                            }
                        }
                        return combine(wrap(value), TemplateString.of(" AS %s".formatted(entry.getKey().qualifiedName(dialect))));
                    })
                    .reduce((left, right) -> combine(left, TemplateString.of(", "), right))
                    .map(t -> combine(TemplateString.of("SELECT "), t, TemplateString.of(" FROM DUAL")))
                    .orElseThrow();
        } catch (SqlTemplateException e) {
            throw new PersistenceException("Failed to map entity to SQL parameters.", e);
        }
    }

    private TemplateString mergeSelect(@Nonnull BindVars bindVars) {
        var dialect = ormTemplate.dialect();
        var values = new AtomicReference<Map<Column, ?>>();
        bindVars.setRecordListener(record -> {
            try {
                //noinspection unchecked
                values.setPlain(model.values((E) record, column -> true));
            } catch (SqlTemplateException e) {
                throw new PersistenceException("Failed to map entity to SQL parameters.", e);
            }
        });
        var duplicates = new HashSet<>();   // CompoundPks may also have their columns included as stand-alone fields. Only include them once.
        return model.columns().stream()
                .filter(column -> duplicates.add(column.name()))
                .map(c -> combine(wrap(bindVar(bindVars, ignore -> values.getPlain().get(c))), TemplateString.of(" AS %s".formatted(c.qualifiedName(dialect)))))
                .reduce((left, right) -> combine(left, TemplateString.of(", "), right))
                .map(t -> combine(TemplateString.of("SELECT "), t, TemplateString.of(" FROM DUAL")))
                .orElseThrow();
    }

    private TemplateString mergeOn() {
        var dialect = ormTemplate.dialect();
        var primaryKeys = model.columns().stream()
                .filter(Column::primaryKey)
                .toList();
        String sql = primaryKeys.stream()
                .map(c -> "t.%s = src.%s".formatted(c.qualifiedName(dialect), c.qualifiedName(dialect)))
                .collect(joining(" AND "));
        return TemplateString.of(sql);
    }

    private TemplateString mergeUpdate(@Nonnull AtomicBoolean versionAware) {
        var dialect = ormTemplate.dialect();
        var duplicates = new HashSet<>();   // CompoundPks may also have their columns included as stand-alone fields. Only include them once.
        var args = model.columns().stream()
                .filter(not(Column::primaryKey))
                .filter(Column::updatable)
                .filter(column -> duplicates.add(column.name()))
                .map(column -> {
                    if (column.version()) {
                        versionAware.setPlain(true);
                        return getVersionString(column);
                    }
                    return "t.%s = src.%s".formatted(column.name(), column.qualifiedName(dialect));
                })
                .toList();
        if (args.isEmpty()) {
            return TemplateString.of("");
        }
        String sql = args.stream().collect(joining(", ", "UPDATE SET ", ""));
        return TemplateString.of("\nWHEN MATCHED THEN\n\t%s".formatted(sql));
    }

    private TemplateString mergeInsert() {
        var dialect = ormTemplate.dialect();
        var insertDuplicates = new HashSet<>();   // CompoundPks may also have their columns included as stand-alone fields. Only include them once.
        var insertArgs = model.columns().stream()
                .filter(c -> !c.primaryKey() || c.generation() != IDENTITY)
                .filter(column -> insertDuplicates.add(column.name()))
                .map(c -> c.qualifiedName(dialect))
                .toList();
        var valuesDuplicates = new HashSet<>();   // CompoundPks may also have their columns included as stand-alone fields. Only include them once.
        var valuesArgs = model.columns().stream()
                .filter(c -> !c.primaryKey() || c.generation() != IDENTITY)
                .filter(column -> valuesDuplicates.add(column.name()))
                .map(c -> "src.%s".formatted(c.qualifiedName(dialect)))
                .toList();
        assert insertArgs.size() == valuesArgs.size();
        if (insertArgs.isEmpty()) {
            return TemplateString.EMPTY;
        }
        String insertSql = insertArgs.stream().collect(joining(", ", "INSERT (", ")"));
        String valuesSql = valuesArgs.stream().collect(joining(", ", "VALUES (", ")"));
        String sql = "\n\t%s\n\t%s".formatted(insertSql, valuesSql);
        return TemplateString.of("\nWHEN NOT MATCHED THEN%s".formatted(sql));
    }

    protected E validateUpsert(@Nonnull E entity) {
        assert !isAutoGeneratedPrimaryKey();
        if (model.isDefaultPrimaryKey(entity.id())) {
            throw new PersistenceException("Primary key must be set for non-auto-generated primary keys for upserts.");
        }
        return entity;
    }

    /**
     * Inserts or updates a single entity in the database.
     *
     * <p>This method performs an "upsert" operation on the provided entity. If the entity does not already exist
     * in the database, it will be inserted. If it does exist, it will be updated to reflect the current state of
     * the entity. This approach ensures that the entity is either created or brought up-to-date, depending on
     * its existence in the database.</p>
     *
     * @param entity the entity to be inserted or updated. The entity must be non-null and contain valid data
     *               for insertion or update in the database.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity
     *                              problems, constraints violations, or invalid entity data.
     */
    @Override
    public void upsert(@Nonnull E entity) {
        if (isUpdate(entity)) {
            update(entity);
            return;
        }
        if (isAutoGeneratedPrimaryKey()) {
            // If it's not an update, it must be an insert when in auto-generated primary key mode.
            insert(entity);
            return;
        }
        validateUpsert(entity);
        var versionAware = new AtomicBoolean();
        intercept(sql -> sql.versionAware(versionAware.getPlain()), () -> {
            var query = ormTemplate.query(flatten(raw("""
                    MERGE INTO \0 t
                    USING (\0) src
                    ON (\0)\0\0""", table(model.type()), mergeSelect(entity), mergeOn(), mergeUpdate(versionAware), mergeInsert())));
            query.executeUpdate();
        });
    }

    /**
     * Inserts or updates a single entity in the database and returns its ID.
     *
     * <p>This method performs an "upsert" operation on the provided entity. If the entity does not already exist
     * in the database, it will be inserted; if it exists, it will be updated. Upon successful completion,
     * the method returns the ID of the entity as stored in the database. This approach ensures that the entity
     * is either created or brought up-to-date, depending on its existence in the database.</p>
     *
     * @param entity the entity to be inserted or updated. The entity must be non-null and contain valid data
     *               for insertion or update in the database.
     * @return the ID of the upserted entity, reflecting its identifier in the database.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity
     *                              problems, constraints violations, or invalid entity data.
     */
    @Override
    public ID upsertAndFetchId(@Nonnull E entity) {
        if (isAutoGeneratedPrimaryKey()) {
            if (generationStrategy == SEQUENCE) {
                throw new PersistenceException("Oracle does not support using sequence-based ID generation together with fetch mode.");
            }
        }
        if (isUpdate(entity)) {
            update(entity);
            return entity.id();
        }
        if (isAutoGeneratedPrimaryKey()) {
            // If it's not an update, it must be an insert when in auto-generated primary key mode.
            return insertAndFetchId(entity);
        }
        validateUpsert(entity);
        upsert(entity);
        return entity.id();
    }

    /**
     * Inserts or updates a single entity in the database and returns the entity with its current state.
     *
     * <p>This method performs an "upsert" operation on the provided entity. If the entity does not already exist
     * in the database, it will be inserted; if it exists, it will be updated. Upon successful completion,
     * the method returns the entity as it exists in the database after the upsert operation. This ensures that
     * the returned entity reflects any modifications applied during the upsert process, such as generated primary keys,
     * updated timestamps, or default values set by the database.</p>
     *
     * @param entity the entity to be inserted or updated. The entity must be non-null and contain valid data
     *               for insertion or update in the database.
     * @return the upserted entity, reflecting its current state in the database. This includes any
     *         database-applied changes, such as primary key assignments, default values, or timestamp updates.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity
     *                              problems, constraints violations, or invalid entity data.
     */
    @Override
    public E upsertAndFetch(@Nonnull E entity) {
        return getById(upsertAndFetchId(entity));
    }

    /**
     * Inserts or updates a collection of entities in the database in batches.
     *
     * <p>This method processes the provided entities in batches, optimizing performance for larger collections by
     * reducing database overhead. For each entity, the method performs an "upsert" operation, meaning it will insert
     * the entity if it does not already exist in the database, or update it if it does. This approach ensures that
     * the entities are either created or brought up-to-date, depending on their existence in the database.</p>
     *
     * @param entities an iterable collection of entities to be inserted or updated. Each entity in the collection must
     *                 be non-null and contain valid data for insertion or update in the database.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity problems,
     *                              constraints violations, or invalid entity data.
     */
    @Override
    public void upsert(@Nonnull Iterable<E> entities) {
        upsert(toStream(entities), defaultBatchSize);
    }

    private sealed interface PartitionKey {}
    private static final class NoOpKey implements PartitionKey {
        private static final NoOpKey INSTANCE = new NoOpKey();
    }
    private static final class InsertKey implements PartitionKey {
        private static final InsertKey INSTANCE = new InsertKey();
    }
    private static final class UpsertKey implements PartitionKey {
        private static final UpsertKey INSTANCE = new UpsertKey();
    }
    private record UpdateKey(@Nonnull Set<Metamodel<? extends Data, ?>> fields) implements PartitionKey {
        UpdateKey() {
            this(Set.of()); // All fields.
        }
    }

    /**
     * Inserts or updates a collection of entities in the database in batches and returns a list of their IDs.
     *
     * <p>This method processes the provided entities in batches to optimize performance for larger collections,
     * reducing database overhead. For each entity, the method performs an "upsert" operation, inserting the entity
     * if it does not already exist in the database, or updating it if it does. Upon successful completion,
     * the method returns a list of the IDs of the upserted entities, reflecting their identifiers as stored
     * in the database.</p>
     *
     * @param entities an iterable collection of entities to be inserted or updated. Each entity in the collection
     *                 must be non-null and contain valid data for insertion or update in the database.
     * @return a list of IDs corresponding to the upserted entities. The order of IDs in the returned list
     *         is not guaranteed to match the order of the input collection.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity problems,
     *                              constraints violations, or invalid entity data.
     */
    @Override
    public List<ID> upsertAndFetchIds(@Nonnull Iterable<E> entities) {
        if (isAutoGeneratedPrimaryKey()) {
            if (generationStrategy == SEQUENCE) {
                throw new PersistenceException("Oracle does not support using sequence-based ID generation together with fetch mode.");
            }
        }
        Map<Set<Metamodel<? extends Data, ?>>, PreparedQuery> updateQueries = new HashMap<>();
        LazySupplier<PreparedQuery> insertQuery = new LazySupplier<>(this::prepareInsertQuery);
        LazySupplier<PreparedQuery> upsertQuery = new LazySupplier<>(this::prepareUpsertQuery);
        try {
            var result = new ArrayList<ID>();
            var entityCache = entityCache();
            partitioned(toStream(entities), defaultBatchSize, entity -> {
                if (isUpdate(entity)) {
                    var dirty = getDirty(entity, entityCache);
                    if (dirty.isEmpty()) {
                        return NoOpKey.INSTANCE;
                    }
                    return new UpdateKey(dirty.get());
                } else if (isAutoGeneratedPrimaryKey()) {
                    return InsertKey.INSTANCE;
                } else {
                    return UpsertKey.INSTANCE;
                }
            }, getMaxShapes(), new UpdateKey()).forEach(partition -> {
                switch (partition.key()) {
                    case NoOpKey ignore -> result.addAll(partition.chunk().stream().map(E::id).toList());
                    case InsertKey ignore -> result.addAll(insertAndFetchIds(partition.chunk(), insertQuery.get()));
                    case UpsertKey ignore -> result.addAll(upsertAndFetchIds(partition.chunk(), upsertQuery.get()));
                    case UpdateKey u -> result.addAll(updateAndFetchIds(partition.chunk(),
                            updateQueries.computeIfAbsent(u.fields(), ignore -> prepareUpdateQuery(u.fields()))));
                }
            });
            return result;
        } finally {
            closeQuietly(Stream.of(updateQueries.values().stream(), insertQuery.value().stream(), upsertQuery.value().stream())
                    .flatMap(identity()));
        }
    }

    /**
     * Inserts or updates a collection of entities in the database in batches and returns a list of the upserted
     * entities.
     *
     * <p>This method processes the provided entities in batches, optimizing performance for larger collections
     * by reducing database overhead. For each entity, it performs an "upsert" operation, inserting the entity if it
     * does not already exist in the database, or updating it if it does. Upon successful completion, it returns
     * the entities as they exist in the database after the operation. This ensures that the returned entities reflect
     * any changes applied during the upsert process, such as generated primary keys, updated timestamps, or default
     * values set by the database.</p>
     *
     * @param entities an iterable collection of entities to be inserted or updated. Each entity in the collection
     *                 must be non-null and contain valid data for insertion or update in the database.
     * @return a list of upserted entities reflecting their current state in the database. The order of entities
     *         in the returned list is not guaranteed to match the order of the input collection.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity problems,
     *                              constraints violations, or invalid entity data.
     */
    @Override
    public List<E> upsertAndFetch(@Nonnull Iterable<E> entities) {
        return findAllById(upsertAndFetchIds(entities));
    }

    /**
     * Inserts or updates a stream of entities in the database in batches.
     *
     * <p>This method processes the provided stream of entities in batches, performing an "upsert" operation on each.
     * For each entity, it will be inserted into the database if it does not already exist; if it does exist, it will
     * be updated to reflect the current state of the entity. Batch processing optimizes the performance of the
     * upsert operation for larger data sets by reducing database overhead.</p>
     *
     * @param entities a stream of entities to be inserted or updated. Each entity in the stream must be non-null
     *                 and contain valid data for insertion or update in the database.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity
     *                              problems, constraints violations, or invalid entity data.
     */
    @Override
    public void upsert(@Nonnull Stream<E> entities) {
        upsert(entities, defaultBatchSize);
    }

    /**
     * Inserts or updates a stream of entities in the database in configurable batch sizes.
     *
     * <p>This method processes the provided stream of entities in batches, performing an "upsert" operation on each.
     * For each entity, it will be inserted if it does not already exist in the database, or updated if it does.
     * The batch size can be configured to control the number of entities processed in each database operation,
     * allowing for optimized performance and memory management based on system requirements.</p>
     *
     * @param entities a stream of entities to be inserted or updated. Each entity in the stream must be non-null
     *                 and contain valid data for insertion or update in the database.
     * @param batchSize the number of entities to process in each batch. A larger batch size may improve performance
     *                  but increase memory usage, while a smaller batch size may reduce memory usage but increase
     *                  the number of database operations.
     * @throws PersistenceException if the upsert operation fails due to database issues, such as connectivity
     *                              problems, constraints violations, or invalid entity data.
     */
    @Override
    public void upsert(@Nonnull Stream<E> entities, int batchSize) {
        Map<Set<Metamodel<? extends Data, ?>>, PreparedQuery> updateQueries = new HashMap<>();
        LazySupplier<PreparedQuery> insertQuery = new LazySupplier<>(this::prepareInsertQuery);
        LazySupplier<PreparedQuery> upsertQuery = new LazySupplier<>(this::prepareUpsertQuery);
        try {
            var entityCache = entityCache();
            partitioned(entities, batchSize, entity -> {
                if (isUpdate(entity)) {
                    var dirty = getDirty(entity, entityCache);
                    if (dirty.isEmpty()) {
                        return NoOpKey.INSTANCE;
                    }
                    return new UpdateKey(dirty.get());
                } else if (isAutoGeneratedPrimaryKey()) {
                    return InsertKey.INSTANCE;
                } else {
                    return UpsertKey.INSTANCE;
                }
            }, getMaxShapes(), new UpdateKey()).forEach(partition -> {
                switch (partition.key()) {
                    case NoOpKey ignore -> {}
                    case InsertKey ignore -> insert(partition.chunk(), insertQuery.get());
                    case UpsertKey ignore -> upsert(partition.chunk(), upsertQuery.get());
                    case UpdateKey u -> update(partition.chunk(),
                            updateQueries.computeIfAbsent(u.fields(), ignore -> prepareUpdateQuery(u.fields())));
                }
            });
        } finally {
            closeQuietly(Stream.of(
                            updateQueries.values().stream(),
                            insertQuery.value().stream(),
                            upsertQuery.value().stream()
                    )
                    .flatMap(identity()));
        }
    }

    private boolean isUpdate(@Nonnull E entity) {
        return isAutoGeneratedPrimaryKey() && !model.isDefaultPrimaryKey(entity.id());
    }

    private Map<Boolean, List<E>> partition(@Nonnull List<E> entities) {
        return entities.stream().collect(partitioningBy(this::isUpdate));
    }

    protected PreparedQuery prepareUpsertQuery() {
        var bindVars = ormTemplate.createBindVars();
        var versionAware = new AtomicBoolean();
        return intercept(sql -> sql.versionAware(versionAware.getPlain()), () ->
                ormTemplate.query(flatten(raw("""
                    MERGE INTO \0 t
                    USING (\0) src
                    ON (\0)\0\0""", table(model.type()), mergeSelect(bindVars), mergeOn(), mergeUpdate(versionAware), mergeInsert()))
                ).prepare());
    }

    protected void upsert(@Nonnull List<E> batch, @Nonnull PreparedQuery query) {
        if (batch.isEmpty()) {
            return;
        }
        batch.stream().map(this::validateUpsert).map(Data.class::cast).forEach(query::addBatch);
        int[] result = query.executeBatch();
        if (IntStream.of(result).anyMatch(r -> r != 0 && r != 1 && r != 2)) {
            throw new PersistenceException("Batch upsert failed.");
        }
    }

    protected List<ID> upsertAndFetchIds(@Nonnull List<E> batch, @Nonnull PreparedQuery query) {
        if (batch.isEmpty()) {
            return List.of();
        }
        batch.stream().map(this::validateUpsert).map(Data.class::cast).forEach(query::addBatch);
        int[] result = query.executeBatch();
        if (IntStream.of(result).anyMatch(r -> r != 0 && r != 1 && r != 2)) {
            throw new PersistenceException("Batch upsert failed.");
        }
        if (isAutoGeneratedPrimaryKey()) {
            try (var generatedKeys = query.getGeneratedKeys(model.primaryKeyType())) {
                return generatedKeys.toList();
            }
        }
        return batch.stream().map(Entity::id).toList();
    }

    @Override
    public ID insertAndFetchId(@Nonnull E entity) {
        if (generationStrategy != SEQUENCE) {
            return super.insertAndFetchId(entity);
        }
        throw new PersistenceException("Oracle does not support using sequence-based ID generation together with fetch mode.");
    }

    @Override
    public List<ID> insertAndFetchIds(@Nonnull Iterable<E> entities) {
        if (generationStrategy != SEQUENCE) {
            return super.insertAndFetchIds(entities);
        }
        throw new PersistenceException("Oracle does not support using sequence-based ID generation together with fetch mode.");
    }

    /**
     * Helper to close lazy-supplied queries without exceptions interrupting each other.
     */
    private void closeQuietly(LazySupplier<PreparedQuery> updateQuery, LazySupplier<PreparedQuery> insertQuery, LazySupplier<PreparedQuery> upsertQuery) {
        try {
            upsertQuery.value().ifPresent(PreparedQuery::close);
        } finally {
            try {
                insertQuery.value().ifPresent(PreparedQuery::close);
            } finally {
                updateQuery.value().ifPresent(PreparedQuery::close);
            }
        }
    }
}