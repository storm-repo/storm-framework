/*
 * Copyright 2024 - 2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package st.orm.template.impl;

import jakarta.annotation.Nonnull;
import st.orm.BindVars;
import st.orm.PersistenceException;
import st.orm.template.SqlTemplate;
import st.orm.template.SqlTemplate.Parameter;
import st.orm.template.SqlTemplateException;
import st.orm.template.impl.Elements.Table;
import st.orm.template.impl.Elements.Values;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.stream.Collectors.joining;

/**
 * A processor for a values element of a template.
 */
final class ValuesProcessor implements ElementProcessor<Values> {

    private final SqlTemplateProcessor templateProcessor;
    private final ModelBuilder modelBuilder;
    private final Table primaryTable;
    private final List<Parameter> parameters;
    private final AtomicInteger parameterPosition;

    ValuesProcessor(@Nonnull SqlTemplateProcessor templateProcessor) {
        this.templateProcessor = templateProcessor;
        this.modelBuilder = templateProcessor.modelBuilder();
        this.primaryTable = templateProcessor.primaryTable();
        this.parameters = templateProcessor.parameters();
        this.parameterPosition = templateProcessor.parameterPosition();
    }

    /**
     * Process a values element of a template.
     *
     * @param values the values element to process.
     * @return the result of processing the element.
     * @throws SqlTemplateException if the template does not comply to the specification.
     */
    @Override
    public ElementResult process(@Nonnull Values values) throws SqlTemplateException {
        if (primaryTable == null) {
            throw new SqlTemplateException("Primary entity not found.");
        }
        if (values.records() != null) {
            return getRecordsString(values.records());
        }
        if (values.bindVars() != null) {
            return getBindVarsString(values.bindVars());
        }
        throw new SqlTemplateException("No values found for Values.");
    }

    /**
     * Returns the SQL string for the specified records.
     *
     * @param records the records to process.
     * @return the SQL string for the specified record.
     * @throws SqlTemplateException if the template does not comply to the specification.
     */
    private ElementResult getRecordsString(@Nonnull Iterable<? extends Record> records) throws SqlTemplateException {
        var table = primaryTable.table();
        List<String> args = new ArrayList<>();
        for (var record : records) {
            if (record == null) {
                throw new SqlTemplateException("Record is null.");
            }
            if (!table.isInstance(record)) {
                throw new SqlTemplateException(STR."Record \{record.getClass().getSimpleName()} does not match entity \{table.getSimpleName()}.");
            }
            var map = ModelMapper.of(modelBuilder.build(record, false))
                    .map(record, column -> !column.autoGenerated() && column.insertable())
                    .sequencedValues();
            if (map.isEmpty()) {
                throw new SqlTemplateException("No values found for Insert.");
            }
            args.add(STR."(\{"?, ".repeat(map.size() - 1)}?)");
            for (var o : map) {
                parameters.add(new SqlTemplate.PositionalParameter(parameterPosition.getAndIncrement(), o));
            }
            args.add(", ");
        }
        if (!args.isEmpty()) {
            args.removeLast();
        }
        return new ElementResult(String.join("", args));
    }

    /**
     * Returns the SQL string for the specified bindVars.
     *
     * @param bindVars the bindVars to process.
     * @return the SQL string for the specified bindVars.
     * @throws SqlTemplateException if the template does not comply to the specification.
     */
    private ElementResult getBindVarsString(@Nonnull BindVars bindVars) throws SqlTemplateException {
        if (bindVars instanceof BindVarsImpl vars) {
            templateProcessor.setBindVars(vars);
            AtomicInteger parameterCount = new AtomicInteger();
            String bindVarsString = modelBuilder.build(primaryTable.table(), false)
                    .columns().stream()
                    .filter(column -> !column.autoGenerated() && column.insertable())
                    .map(_ -> {
                        parameterCount.incrementAndGet();
                        return "?";
                    })
                    .collect(joining(", "));
            final int fixedParameterPosition = parameterPosition.get();
            vars.addParameterExtractor(record -> {
                try {
                    AtomicInteger position = new AtomicInteger(fixedParameterPosition);
                    return ModelMapper.of(modelBuilder.build(record, false))
                            .map(record, column -> !column.autoGenerated() && column.insertable())
                            .sequencedValues()
                            .stream()
                            .map(o -> new SqlTemplate.PositionalParameter(position.getAndIncrement(), o))
                            .toList();
                } catch (SqlTemplateException ex) {
                    // BindVars works at the abstraction level of the ORM, so we throw a PersistenceException here.
                    throw new PersistenceException(ex);
                }
            });
            parameterPosition.set(parameterPosition.get() + parameterCount.getPlain());
            return new ElementResult(STR."(\{bindVarsString})");
        }
        throw new SqlTemplateException("Unsupported BindVars type.");
    }
}
