/*
 * Copyright 2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package st.orm.template.impl;

import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import st.orm.BindVars;
import st.orm.FK;
import st.orm.Lazy;
import st.orm.PK;
import st.orm.Persist;
import st.orm.PersistenceException;
import st.orm.Query;
import st.orm.Version;
import st.orm.spi.ORMReflection;
import st.orm.spi.Providers;
import st.orm.template.ColumnNameResolver;
import st.orm.template.ForeignKeyResolver;
import st.orm.template.Operator;
import st.orm.template.Sql;
import st.orm.template.SqlTemplate.BindVariables;
import st.orm.template.SqlTemplate.NamedParameter;
import st.orm.template.SqlTemplate.Parameter;
import st.orm.template.SqlTemplate.PositionalParameter;
import st.orm.template.SqlTemplateException;
import st.orm.template.impl.Elements.Alias;
import st.orm.template.impl.Elements.Delete;
import st.orm.template.impl.Elements.Expression;
import st.orm.template.impl.Elements.From;
import st.orm.template.impl.Elements.Insert;
import st.orm.template.impl.Elements.ObjectExpression;
import st.orm.template.impl.Elements.Param;
import st.orm.template.impl.Elements.Select;
import st.orm.template.impl.Elements.Set;
import st.orm.template.impl.Elements.Subquery;
import st.orm.template.impl.Elements.Table;
import st.orm.template.impl.Elements.TableSource;
import st.orm.template.impl.Elements.TableTarget;
import st.orm.template.impl.Elements.TemplateExpression;
import st.orm.template.impl.Elements.TemplateSource;
import st.orm.template.impl.Elements.TemplateTarget;
import st.orm.template.impl.Elements.Unsafe;
import st.orm.template.impl.Elements.Update;
import st.orm.template.impl.Elements.Values;
import st.orm.template.impl.Elements.Where;
import st.orm.template.impl.SqlTemplateImpl.BindVarsImpl;
import st.orm.template.impl.SqlTemplateImpl.Join;
import st.orm.template.impl.SqlTemplateImpl.Wrapped;

import java.lang.reflect.RecordComponent;
import java.math.BigInteger;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.SequencedMap;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Stream;

import static java.util.Arrays.asList;
import static java.util.List.copyOf;
import static java.util.Objects.requireNonNull;
import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;
import static java.util.stream.Collectors.joining;
import static st.orm.spi.Providers.getORMConverter;
import static st.orm.template.Operator.EQUALS;
import static st.orm.template.ResolveScope.CASCADE;
import static st.orm.template.ResolveScope.INNER;
import static st.orm.template.impl.SqlTemplateImpl.findComponent;
import static st.orm.template.impl.SqlTemplateImpl.getColumnName;
import static st.orm.template.impl.SqlTemplateImpl.getFkComponents;
import static st.orm.template.impl.SqlTemplateImpl.getForeignKey;
import static st.orm.template.impl.SqlTemplateImpl.getPkComponents;
import static st.orm.template.impl.SqlTemplateImpl.getTableName;
import static st.orm.template.impl.SqlTemplateImpl.isAutoGenerated;
import static st.orm.template.impl.SqlTemplateImpl.toPathString;

/**
 *
 */
record ElementProcessor(
        @Nonnull SqlTemplateImpl sqlTemplate,
        @Nonnull Element element,
        @Nonnull List<Parameter> parameters,
        @Nonnull AtomicInteger parameterPosition,
        @Nonnull AtomicInteger nameIndex,
        @Nonnull AliasMapper aliasMapper,
        @Nonnull TableMapper tableMapper,
        @Nonnull AtomicReference<BindVariables> bindVariables,
        @Nonnull List<String> generatedKeys,
        @Nonnull AtomicBoolean versionAware,
        @Nullable Table primaryTable
) {
    private static final ORMReflection REFLECTION = Providers.getORMReflection();

    record ElementResult(@Nonnull String sql, @Nonnull List<String> args) {
        public ElementResult {
            requireNonNull(sql, "sql");
            requireNonNull(args, "args");
        }
        public ElementResult(@Nonnull String sql) {
            this(sql, List.of());
        }
    }

    private static final ScopedValue<ElementProcessor> CURRENT_PROCESSOR = ScopedValue.newInstance();

    static Optional<ElementProcessor> current() {
        return ofNullable(CURRENT_PROCESSOR.orElse(null));
    }

    Optional<ElementResult> process() throws SqlTemplateException {
        Element fromResolved = element;
        StringBuilder sql = new StringBuilder();
        List<String> args = new ArrayList<>();
        for (Element fromWrapped : fromResolved instanceof Wrapped(var elements) ? elements : List.of(fromResolved)) {
            ElementResult result = switch (fromWrapped) {
                case Wrapped _ -> {
                    assert false;
                    yield null;
                }
                case Select it -> select(it);
                case Insert it -> insert(it);
                case Update it -> update(it);
                case Delete it -> delete(it);
                case From it -> from(it);
                case Join it -> join(it);
                case Table it -> table(it);
                case Alias it -> alias(it);
                case Set it -> set(it);
                case Where it -> where(it);
                case Values it -> values(it);
                case Param it -> param(it);
                case Subquery it -> subquery(it);
                case Unsafe it -> unsafe(it);
            };
            sql.append(result.sql());
            args.addAll(result.args());
        }
        if (!sql.isEmpty() || !args.isEmpty()) {
            return Optional.of(new ElementResult(sql.toString(), args));
        }
        return empty();
    }

    ElementResult select(Select select) throws SqlTemplateException {
        return new ElementResult(getColumnsStringForSelect(select.table(),
                aliasMapper,
                primaryTable == null ? null : primaryTable.table(),
                sqlTemplate.columnNameResolver(),
                sqlTemplate.foreignKeyResolver()));
    }

    ElementResult insert(Insert it) throws SqlTemplateException {
        return new ElementResult(STR."\{getTableName(it.table(), sqlTemplate.tableNameResolver())} (\{getColumnsStringForInsert(it.table(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver(), generatedKeys)})");
    }

    ElementResult update(Update it) {
        return new ElementResult(STR."\{getTableName(it.table(), sqlTemplate.tableNameResolver())}\{it.alias().isEmpty() ? "" : STR." \{it.alias()}"}");
    }

    ElementResult delete(Delete it) {
        return new ElementResult(STR."\{it.alias().isEmpty() ? "" : STR."\{it.alias()}"}");
    }

    ElementResult from(From it) throws SqlTemplateException {
        return switch (it) {
            case From(TableSource ts, _, _) -> new ElementResult(STR."\{getTableName(ts.table(), sqlTemplate.tableNameResolver())}\{it.alias().isEmpty() ? "" : STR." \{it.alias()}"}");
            case From(TemplateSource ts, _, _) -> {
                var from = parse(ts.template(), false);   // From-clause is not correlated.
                yield new ElementResult(STR."(\{from})\{it.alias().isEmpty() ? "" : STR." \{it.alias()}"}");
            }
        };
    }

    ElementResult join(Join join) throws SqlTemplateException {
        if (join.type().hasOnClause()) {
            ElementResult on = switch (join.target()) {
                case TableTarget(var toTable) when join.source() instanceof TableSource(var fromTable) -> {
                    var leftComponents = getFkComponents(fromTable).toList();
                    var rightComponents = getFkComponents(toTable).toList();
                    var leftComponent = findComponent(leftComponents, toTable);
                    Supplier<SqlTemplateException> exception = () -> new SqlTemplateException(STR."Failed to join \{fromTable.getSimpleName()} with \{toTable.getSimpleName()}.");
                    if (leftComponent.isPresent()) {
                        // Joins foreign key of left table to primary key of right table.
                        var fk = getForeignKey(leftComponent.get(), sqlTemplate.foreignKeyResolver());
                        var pk = getColumnName(getPkComponents(toTable).findFirst().orElseThrow(exception), sqlTemplate.columnNameResolver());
                        yield new ElementResult(STR."\{aliasMapper.getAlias(fromTable, null, INNER)}.\{fk} = \{aliasMapper.getAlias(toTable, null, INNER)}.\{pk}");
                    } else {
                        var rightComponent = findComponent(rightComponents, fromTable);
                        if (rightComponent.isPresent()) {
                            // Joins foreign key of right table to primary key of left table.
                            var fk = getForeignKey(rightComponent.get(), sqlTemplate.foreignKeyResolver());
                            var pk = getColumnName(getPkComponents(fromTable).findFirst().orElseThrow(exception), sqlTemplate.columnNameResolver());
                            yield new ElementResult(STR."\{aliasMapper.getAlias(fromTable, null, INNER)}.\{pk} = \{aliasMapper.getAlias(toTable, null, INNER)}.\{fk}");
                        } else {
                            // Joins foreign keys of two compound primary keys.
                            leftComponent = leftComponents.stream()
                                    .filter(f -> rightComponents.stream().anyMatch(r -> r.getType().equals(f.getType())))
                                    .findFirst();
                            rightComponent = rightComponents.stream()
                                    .filter(f -> leftComponents.stream().anyMatch(l -> l.getType().equals(f.getType())))
                                    .findFirst();
                            var fk = getForeignKey(leftComponent.orElseThrow(exception), sqlTemplate.foreignKeyResolver());
                            var pk = getForeignKey(rightComponent.orElseThrow(exception), sqlTemplate.foreignKeyResolver());
                            yield new ElementResult(STR."\{aliasMapper.getAlias(fromTable, null, INNER)}.\{fk} = \{aliasMapper.getAlias(toTable, null, INNER)}.\{pk}");
                        }
                    }
                }
                case TableTarget _ -> throw new SqlTemplateException("Unsupported source type.");   // Should not happen. See Join validation logic.
                case TemplateTarget ts -> new ElementResult(parse(ts.template(), true));   // On-clause is correlated.
            };
            return switch (join) {
                case Join(TableSource ts, var alias, _, _) ->
                        new ElementResult(STR."\n\{join.type().sql()} \{getTableName(ts.table(), sqlTemplate.tableNameResolver())} \{aliasMapper.useAlias(ts.table(), alias)} ON \{on.sql()}", on.args());
                case Join(TemplateSource ts, var alias, _, _) -> {
                    var source = parse(ts.template(), false);   // Source is not correlated.
                    yield new ElementResult(STR."\n\{join.type().sql()} (\{source}) \{alias} ON \{on.sql()}", on.args());
                }
            };
        }
        return switch (join) {
            case Join(TableSource ts, var alias, _, _) -> new ElementResult(STR."\n\{join.type().sql()} \{getTableName(ts.table(), sqlTemplate.tableNameResolver())}\{alias.isEmpty() ? "" : STR." \{alias}"}");
            case Join(TemplateSource ts, var alias, _, _) -> {
                var source = parse(ts.template(), false);   // Source is not correlated.
                yield new ElementResult(STR."\n\{join.type().sql()} (\{source})\{alias.isEmpty() ? "" : STR." \{alias}"}");
            }
        };
    }

    ElementResult table(Table it) {
        StringBuilder s = new StringBuilder();
        s.append(getTableName(it.table(), sqlTemplate.tableNameResolver()));
        if (!it.alias().isEmpty()) {
            s.append(STR." \{it.alias()}");
        }
        return new ElementResult(s.toString());
    }

    ElementResult alias(Alias it) throws SqlTemplateException {
        return new ElementResult(aliasMapper.getAlias(it.table(), it.path(), it.scope()));
    }

    ElementResult set(Set it) throws SqlTemplateException {
        if (primaryTable == null) {
            throw new SqlTemplateException("Primary entity not found.");
        }
        if (it.record() != null) {
            if (!primaryTable.table().isInstance(it.record())) {
                throw new SqlTemplateException(STR."Record \{it.record().getClass().getSimpleName()} does not match entity \{primaryTable.table().getSimpleName()}.");
            }
            var valueMap = getValuesForSet(it.record(), primaryTable.alias(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver(), versionAware);
            List<String> args = new ArrayList<>();
            for (var entry : valueMap.entrySet()) {
                args.add(STR."\{entry.getKey()} = ?");
                parameters.add(new PositionalParameter(parameterPosition.getAndIncrement(), entry.getValue()));
                args.add(", ");
            }
            if (versionAware.getPlain()) {
                for (RecordComponent component : it.record().getClass().getRecordComponents()) {
                    if (component.isAnnotationPresent(Version.class)) {
                        String columnName = getColumnName(component, sqlTemplate.columnNameResolver());
                        String updateExpression = switch (component.getType()) {
                            case Class<?> c when Integer.TYPE.isAssignableFrom(c)
                                    || Long.TYPE.isAssignableFrom(c)
                                    || Integer.class.isAssignableFrom(c)
                                    || Long.class.isAssignableFrom(c)
                                    || BigInteger.class.isAssignableFrom(c) -> STR."\{columnName} + 1";
                            case Class<?> c when Instant.class.isAssignableFrom(c)
                                    || Date.class.isAssignableFrom(c)
                                    || Calendar.class.isAssignableFrom(c)
                                    || Timestamp.class.isAssignableFrom(c) -> "CURRENT_TIMESTAMP";
                            default ->
                                    throw new SqlTemplateException(STR."Unsupported version type: \{component.getType().getSimpleName()}.");
                        };
                        String alias = primaryTable.alias();
                        args.add(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{columnName} = \{updateExpression}");
                        args.add(", ");
                        break;
                    }
                }
            }
            if (!args.isEmpty()) {
                args.removeLast();
            }
            return new ElementResult(String.join("", args));
        } else if (it.bindVars() != null) {
            if (it.bindVars() instanceof BindVarsImpl vars) {
                String bindVarsStr = getBindVarsStringForSet(primaryTable.table(), primaryTable.alias(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver());
                bindVariables.set(vars);
                final int fixedParameterPosition = parameterPosition.get();
                vars.addParameterExtractor(record -> {
                    try {
                        AtomicInteger position = new AtomicInteger(fixedParameterPosition);
                        return getValuesForSet(record, primaryTable.alias(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver(), versionAware)
                                .values().stream()
                                .map(o -> new PositionalParameter(position.getAndIncrement(), o))
                                .toList();
                    } catch (SqlTemplateException ex) {
                        // BindVars works at the abstraction level of the ORM, so we throw a PersistenceException here.
                        throw new PersistenceException(ex);
                    }
                });
                parameterPosition.set(parameterPosition.get() + (int) bindVarsStr.chars().filter(ch -> ch == '?').count()); // We can find a better way to increase the parameterPosition.
                return new ElementResult(bindVarsStr);
            }
            throw new SqlTemplateException("Unsupported BindVars type.");
        }
        throw new SqlTemplateException("No values found for Set.");
    }

    private Object resolveSubqueries(@Nullable Object value) {
        return switch (value) {
            case Templatable t -> new Subquery(t.asStringTemplate(), true);
            case StringTemplate t -> new Subquery(t, true);
            case null, default -> value;
        };
    }

    private String getTemplateExpressionString(@Nonnull StringTemplate template) throws SqlTemplateException{
        var fragments = template.fragments();
        var values = template.values();
        List<String> parts = new ArrayList<>();
        for (int i = 0; i < fragments.size(); i++) {
            String fragment = fragments.get(i);
            parts.add(fragment);
            if (i < values.size()) {
                Object value = resolveSubqueries(values.get(i));
                switch (value) {
                    case Expression exp -> parts.add(getExpressionString(exp));
                    case Subquery s -> parts.add(parse(s.template(), s.correlate()));
                    case Unsafe u -> parts.add(u.sql());
                    case Table t -> parts.add(STR."\{getTableName(t.table(), sqlTemplate.tableNameResolver())}\{t.alias().isEmpty() ? "" : STR." \{t.alias()}"}");
                    case Alias a -> parts.add(aliasMapper.getAlias(a.table(), a.path(), a.scope()));
                    case Param p when p.name() != null -> parts.add(registerParam(p.name(), p.dbValue()));
                    case Param p -> parts.add(registerParam(p.dbValue()));
                    case Record r -> parts.add(getObjectExpressionString(r, EQUALS, null));
                    case Class<?> c when c.isRecord() -> //noinspection unchecked
                            parts.add(aliasMapper.getAlias((Class<? extends Record>) c, null, CASCADE));
                    case Object k when REFLECTION.isSupportedType(k) -> parts.add(aliasMapper.getAlias(REFLECTION.getRecordType(k), null, CASCADE));
                    case Stream<?> _ -> throw new SqlTemplateException("Stream not supported in expression.");
                    case Query _ -> throw new SqlTemplateException("Query not supported in expression. Use QueryBuilder instead.");
                    case Element e -> throw new SqlTemplateException(STR."Unsupported element type in expression: \{e.getClass().getSimpleName()}.");
                    default -> parts.add(registerParam(value));
                }
            }
        }
        return String.join("", parts);
    }

    private String getExpressionString(Expression expression) throws SqlTemplateException {
        return switch(expression) {
            case TemplateExpression it -> getTemplateExpressionString(it.template());
            case ObjectExpression it -> getObjectExpressionString(it.object(), it.operator(), it.path());
        };
    }

    private String getObjectExpressionString(@Nonnull Object object, @Nonnull Operator operator, @Nullable String path)
            throws SqlTemplateException {
        if (primaryTable == null) {
            throw new SqlTemplateException("Primary table unknown.");
        }
        var table = primaryTable.table();
        Iterable<?> iterable = switch (object) {
            case null -> throw new SqlTemplateException("Null object not supported.");
            case Object[] a -> asList(a);   // Use this instead of List.of() to allow null values.
            case Iterable<?> i -> i;
            case BindVars _ -> throw new SqlTemplateException("BindVars not supported in this context.");
            case Stream<?> _ -> throw new SqlTemplateException("Stream not supported in this context. Use Iterable or varargs instead.");
            case StringTemplate _ -> throw new SqlTemplateException("String template not supported in this context. Use expression method instead.");
            default -> List.of(object); // Not expected at the moment though.
        };
        Class<?> pkType = REFLECTION.findPKType(primaryTable.table()).orElse(null);
        String column = null;
        int size = 0;
        List<String> args = new ArrayList<>();
        for (var o : iterable) {
            if (o == null) {
                parameters.add(new PositionalParameter(parameterPosition.getAndIncrement(), null));
                size++;
                continue;
            }
            Class<?> elementType = o.getClass();
            Map<String, Object> valueMap;
            if (path == null && (pkType != null && (pkType == elementType || (pkType.isPrimitive() && isPrimitiveCompatible(o, pkType))))) {
                assert primaryTable != null;
                valueMap = getValuesForCondition(o, table, primaryTable.alias(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver());
                if (valueMap.isEmpty()) {
                    throw new SqlTemplateException(STR."Failed to find primary key field for \{o.getClass().getSimpleName()} argument on \{table.getSimpleName()} table.");
                }
            } else if (elementType.isRecord()) {
                assert primaryTable != null;
                valueMap = getValuesForCondition((Record) o, path, table, primaryTable.alias(), tableMapper, sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver(), versionAware.getPlain());
                if (valueMap.isEmpty()) {
                    throw new SqlTemplateException(STR."Failed to find field for \{o.getClass().getSimpleName()} argument on \{table.getSimpleName()} table graph.");
                }
            } else if (path != null) {
                valueMap = getValuesForCondition(o, path, table, aliasMapper, sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver());
                if (valueMap.isEmpty()) {
                    throw new SqlTemplateException(STR."Failed to find field for \{o.getClass().getSimpleName()} argument on \{table.getSimpleName()} table at path '\{path}'.");
                }
            } else {
                throw new SqlTemplateException(STR."Failed to find field for \{o.getClass().getSimpleName()} argument on \{table.getSimpleName()} table without a path.");
            }
            if (valueMap.size() == 1) {
                var entry = valueMap.entrySet().iterator().next();
                parameters.add(new PositionalParameter(parameterPosition.getAndIncrement(), entry.getValue()));
                var k = entry.getKey();
                if (column != null) {
                    if (!column.equals(k)) {
                        throw new SqlTemplateException(STR."Multiple columns specified by where-clause argument: \{column} and \{k}.");
                    }
                }
                column = k;
                size++;
            } else {
                if (column != null) {
                    throw new SqlTemplateException("Multiple columns specified by where-clause arguments.");
                }
                try {
                    args.add(STR."(\{valueMap.keySet().stream()
                            .map(k -> operator.format(k, 1))
                            .collect(joining(" AND "))})");
                } catch (IllegalArgumentException e) {
                    throw new SqlTemplateException(e);
                }
                args.add(" OR ");
                parameters.addAll(valueMap.values().stream()
                        .map(v -> new PositionalParameter(parameterPosition.getAndIncrement(), v))
                        .toList());
            }
        }
        if (!args.isEmpty()) {
            args.removeLast();
            return String.join("", args);
        }
        if (column == null) {
            var valueMap = path != null
                    ? getValuesForCondition(null, path, table, aliasMapper, sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver())
                    : getValuesForCondition(null, table, primaryTable.alias(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver());
            if (valueMap.size() == 1) {
                column = valueMap.sequencedKeySet().getFirst();
            }
        }
        if (column == null) {
            if (path == null) {
                throw new SqlTemplateException(STR."Failed to find field for \{table.getSimpleName()}.");
            } else {
                throw new SqlTemplateException(STR."Failed to find field for \{table.getSimpleName()} table at path \{path}.");
            }
        }
        try {
            return operator.format(column, size);
        } catch (IllegalArgumentException e) {
            throw new SqlTemplateException(e);
        }
    }

    ElementResult where(Where it) throws SqlTemplateException {
        if (primaryTable == null) {
            throw new SqlTemplateException("Primary entity not found.");
        }
        Expression expression = it.expression();
        if (expression != null) {
            return new ElementResult(getExpressionString(expression));
        } else if (it.bindVars() != null) {
            String bindVarsStr = getBindVarsStringForWhere(primaryTable.table(), primaryTable.alias(), sqlTemplate.columnNameResolver());
            if (it.bindVars() instanceof BindVarsImpl vars) {
                bindVariables.set(vars);
                final int fixedParameterPosition = parameterPosition.get();
                vars.addParameterExtractor(record -> {
                    try {
                        AtomicInteger position = new AtomicInteger(fixedParameterPosition);
                        return getValuesForCondition(record, null, primaryTable.table(), primaryTable.alias(), tableMapper, sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver(), versionAware.getPlain())
                                .values().stream()
                                .map(o -> new PositionalParameter(position.getAndIncrement(), o))
                                .toList();
                    } catch (SqlTemplateException ex) {
                        // BindVars works at the abstraction level of the ORM, so we throw a PersistenceException here.
                        throw new PersistenceException(ex);
                    }
                });
                parameterPosition.set(parameterPosition.get() + (int) bindVarsStr.chars().filter(ch -> ch == '?').count()); // We can find a better way to increase the parameterPosition.
                return new ElementResult(bindVarsStr);
            }
            throw new SqlTemplateException("Unsupported BindVars type.");
        }
        throw new SqlTemplateException("No values found for Where.");
    }

    ElementResult values(Values it) throws SqlTemplateException {
        if (primaryTable == null) {
            throw new SqlTemplateException("Primary entity not found.");
        }
        var table = primaryTable.table();
        var records = it.records();
        if (records != null) {
            List<String> args = new ArrayList<>();
            for (var record : records) {
                if (record == null) {
                    throw new SqlTemplateException("Record is null.");
                }
                if (!table.isInstance(record)) {
                    throw new SqlTemplateException(STR."Record \{record.getClass().getSimpleName()} does not match entity \{table.getSimpleName()}.");
                }
                List<?> valueList = getValuesForInsert(record);
                if (valueList.isEmpty()) {
                    throw new SqlTemplateException("No values found for Insert.");
                }
                args.add(STR."(\{"?, ".repeat(valueList.size() - 1)}?)");
                for (var o : valueList) {
                    parameters().add(new PositionalParameter(parameterPosition.getAndIncrement(), o));
                }
                args.add(", ");
            }
            if (!args.isEmpty()) {
                args.removeLast();
            }
            return new ElementResult(String.join("", args));
        } else if (it.bindVars() != null) {
            if (it.bindVars() instanceof BindVarsImpl vars) {
                String bindVarsStr = getBindVarsStringForInsert(primaryTable.table(), sqlTemplate.columnNameResolver(), sqlTemplate.foreignKeyResolver());
                bindVariables.set(vars);
                final int fixedParameterPosition = parameterPosition.get();
                vars.addParameterExtractor(record -> {
                    try {
                        AtomicInteger position = new AtomicInteger(fixedParameterPosition);
                        return getValuesForInsert(record).stream()
                                .map(o -> new PositionalParameter(position.getAndIncrement(), o))
                                .toList();
                    } catch (SqlTemplateException ex) {
                        // BindVars works at the abstraction level of the ORM, so we throw a PersistenceException here.
                        throw new PersistenceException(ex);
                    }
                });
                parameterPosition.set(parameterPosition.get() + (int) bindVarsStr.chars().filter(ch -> ch == '?').count()); // We can find a better way to increase the parameterPosition.
                return new ElementResult(STR."(\{bindVarsStr})");
            }
            throw new SqlTemplateException("Unsupported BindVars type.");
        }
        throw new SqlTemplateException("No values found for Values.");
    }

    private String toArgsString(Iterable<?> iterable) {
        List<String> args = new ArrayList<>();
        for (var v : iterable) {
            args.add("?");
            args.add(", ");
            parameters.add(new PositionalParameter(parameterPosition.getAndIncrement(), v));
        }
        if (!args.isEmpty()) {
            args.removeLast();    // Remove last ", " element.
        }
        return String.join("", args);
    }

    private String registerParam(@Nullable Object value) throws SqlTemplateException {
        return switch (value) {
            case Object[] array when sqlTemplate.expandCollection() -> toArgsString(List.of(array));
            case Iterable<?> it when sqlTemplate.expandCollection() -> toArgsString(it);
            case Object[] _ -> throw new SqlTemplateException("Array parameters not supported.");
            case Iterable<?> _ -> throw new SqlTemplateException("Collection parameters not supported.");
            case null, default -> {
                parameters.add(new PositionalParameter(parameterPosition.getAndIncrement(), value));
                yield "?";
            }
        };
    }

    private String registerParam(@Nonnull String name, @Nullable Object value) throws SqlTemplateException {
        if (sqlTemplate.positionalOnly()) {
            throw new SqlTemplateException("Named parameters not supported.");
        }
        parameters.add(new NamedParameter(name, value));
        return STR.":\{name}";
    }

    ElementResult param(Param p) throws SqlTemplateException {
        if (p.name() != null) {
            if (sqlTemplate.positionalOnly()) {
                throw new SqlTemplateException("Named parameters not supported.");
            }
            return new ElementResult(registerParam(p.name(), p.dbValue()));
        } else {
            if (sqlTemplate.positionalOnly()) {
                return new ElementResult(registerParam(p.dbValue()));
            }
            String name = STR."_p\{nameIndex.getAndIncrement()}";
            return new ElementResult(registerParam(name, p.dbValue()));
        }
    }

    ElementResult subquery(Subquery it) throws SqlTemplateException{
        return new ElementResult(parse(it.template(), it.correlate()));
    }

    String parse(StringTemplate template, boolean correlate) throws SqlTemplateException{
        Callable<String> callable = () -> {
            Sql sql = sqlTemplate.process(template, true);
            for (var parameter : sql.parameters()) {
                switch (parameter) {
                    case PositionalParameter p -> registerParam(p.dbValue());
                    case NamedParameter n -> registerParam(n.name(), n.dbValue());
                }
            }
            return sql.statement();
        };
        try {
            if (correlate) {
                return ScopedValue.callWhere(CURRENT_PROCESSOR, this, callable);
            }
            return callable.call();
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Exception e) {
            throw new SqlTemplateException(e);
        }
    }

    ElementResult unsafe(Unsafe it) {
        return new ElementResult(it.sql());
    }

    public static @Nullable List<RecordComponent> resolvePath(Class<? extends Record> root, Class<? extends Record> target) throws SqlTemplateException{
        List<RecordComponent> path = new ArrayList<>();
        List<RecordComponent> searchPath = new ArrayList<>(); // Temporary path for exploration.
        int pathsFound = resolvePath(root, target, searchPath, path, 0);
        if (pathsFound == 0) {
            return null;
        } else if (pathsFound > 1) {
            throw new SqlTemplateException(STR."Multiple paths to the target \{target.getSimpleName()} found in \{root.getSimpleName()}.");
        }
        return path;
    }

    private static int resolvePath(Class<? extends Record> current, Class<? extends Record> target,
                                   List<RecordComponent> searchPath, List<RecordComponent> path, int pathsFound) {
        if (current == target) {
            if (pathsFound == 0) {
                path.clear();
                path.addAll(searchPath);
            }
            return pathsFound + 1;
        }
        for (RecordComponent component : current.getRecordComponents()) {
            Class<?> componentType = component.getType();
            if (componentType.isRecord() && REFLECTION.isAnnotationPresent(component, FK.class)) {
                searchPath.add(component);
                //noinspection unchecked
                pathsFound = resolvePath((Class<? extends Record>) componentType, target, searchPath, path, pathsFound);
                if (pathsFound > 1) {
                    return pathsFound; // Early return if multiple paths are found.
                }
                searchPath.removeLast();
            } else if (componentType == target) {
                searchPath.add(component);
                pathsFound++;
                if (pathsFound == 1) {
                    path.clear();
                    path.addAll(searchPath);
                }
                searchPath.removeLast();
                if (pathsFound > 1) {
                    return pathsFound;
                }
            }
        }
        return pathsFound;
    }

    private static String getColumnsStringForSelect(@Nonnull Class<? extends Record> type,
                                                    @Nonnull AliasMapper aliasMapper,
                                                    @Nullable Class<? extends Record> primaryTable,
                                                    @Nullable ColumnNameResolver columnNameResolver,
                                                    @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        var parts = new ArrayList<String>();
        // Resolve the path of type, starting from the primary table. This will help in resolving the alias in case the same table is used multiple times.
        List<RecordComponent> path = null;
        String pathString = null;
        if (primaryTable != null) {
            List<RecordComponent> pathList = resolvePath(primaryTable, type);
            if (pathList != null) {
                path = pathList;
                pathString = toPathString(pathList);
            }
        }
        getColumnsStringForSelect(type, path, aliasMapper, primaryTable, aliasMapper.findAlias(type, pathString, INNER) // Only use local aliases.
                .orElse(""), parts, columnNameResolver, foreignKeyResolver);
        if (!parts.isEmpty()) {
            parts.removeLast();
        }
        return java.lang.String.join("", parts);
    }

    private static void getColumnsStringForSelect(@Nonnull Class<? extends Record> type,
                                                  @Nullable List<RecordComponent> path,
                                                  @Nonnull AliasMapper aliasMapper,
                                                  @Nullable Class<? extends Record> primaryTable,
                                                  @Nonnull String alias,
                                                  @Nonnull List<String> parts,
                                                  @Nullable ColumnNameResolver columnNameResolver,
                                                  @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        for (var component : type.getRecordComponents()) {
            var converter = getORMConverter(component).orElse(null);
            if (converter != null) {
                converter.getColumns(c -> getColumnName(c, columnNameResolver)).forEach(name -> {
                    if (!alias.isEmpty()) {
                        parts.add(STR."\{alias}.\{name}");
                    } else {
                        parts.add(name);
                    }
                    parts.add(", ");
                });
            } else if (component.getType().isRecord()) {
                @SuppressWarnings("unchecked")
                var recordType = (Class<? extends Record>) component.getType();
                List<RecordComponent> newPath;
                if (path != null) {
                    newPath = new ArrayList<>(path);
                    newPath.add(component);
                    newPath = copyOf(newPath);
                } else if (recordType == primaryTable) {
                    newPath = List.of();
                } else {
                    newPath = null;
                }
                getColumnsStringForSelect(recordType, newPath, aliasMapper, primaryTable, getAlias(recordType, newPath, alias, aliasMapper), parts, columnNameResolver, foreignKeyResolver);
            } else if (Lazy.class.isAssignableFrom(component.getType())) {
                if (!REFLECTION.isAnnotationPresent(component, FK.class)) {
                    throw new SqlTemplateException(STR."Lazy component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is not a foreign key.");
                }
                String name = getForeignKey(component, foreignKeyResolver);
                if (!alias.isEmpty()) {
                    parts.add(STR."\{alias}.\{name}");
                } else {
                    parts.add(name);
                }
                parts.add(", ");
            } else {
                String name = getColumnName(component, columnNameResolver);
                if (!alias.isEmpty()) {
                    parts.add(STR."\{alias}.\{name}");
                } else {
                    parts.add(name);
                }
                parts.add(", ");
            }
        }
    }

    private static String getColumnsStringForInsert(@Nonnull Class<? extends Record> type,
                                                    @Nullable ColumnNameResolver columnNameResolver,
                                                    @Nullable ForeignKeyResolver foreignKeyResolver,
                                                    @Nonnull List<String> generatedKeys) throws SqlTemplateException {
        return getStringForInsert(type, false, columnNameResolver, foreignKeyResolver, generatedKeys, false);
    }

    private static String getBindVarsStringForInsert(@Nonnull Class<? extends Record> type,
                                                     @Nullable ColumnNameResolver columnNameResolver,
                                                     @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        return getStringForInsert(type, true, columnNameResolver, foreignKeyResolver, new ArrayList<>(), false);
    }

    private static String getStringForInsert(@Nonnull Class<? extends Record> type,
                                             boolean placeholders,
                                             @Nullable ColumnNameResolver columnNameResolver,
                                             @Nullable ForeignKeyResolver foreignKeyResolver,
                                             @Nonnull List<String> generatedKeys,
                                             boolean primaryKey) throws SqlTemplateException {
        var parts = new ArrayList<String>();
        for (var component : type.getRecordComponents()) {
            Persist persist = REFLECTION.getAnnotation(component, Persist.class);
            if (persist != null && !persist.insertable()) {
                continue;
            }
            var converter = getORMConverter(component).orElse(null);
            if (converter != null) {
                converter.getColumns(c -> getColumnName(c, columnNameResolver)).forEach(column -> {
                    if (primaryKey) {
                        generatedKeys.add(column);
                    }
                    parts.add(placeholders ? "?" : column);
                    parts.add(", ");
                });
                continue;
            }
            PK pk = REFLECTION.getAnnotation(component, PK.class);
            if (pk != null) {
                if (!component.getType().isRecord()) {  // Record PKs will be handled below.
                    generatedKeys.add(getColumnName(component, columnNameResolver));
                }
                if (isAutoGenerated(component)) {
                    continue;
                }
            }
            if (Lazy.class.isAssignableFrom(component.getType())) {
                parts.add(placeholders ? "?" : getForeignKey(component, foreignKeyResolver));
                parts.add(", ");
                continue;
            }
            if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                parts.add(placeholders ? "?" : getForeignKey(component, foreignKeyResolver));
                parts.add(", ");
                continue;
            }
            if (component.getType().isRecord()) {
                // @Inline is implicitly assumed.
                //noinspection unchecked
                String str = getStringForInsert((Class<? extends Record>) component.getType(), placeholders, columnNameResolver, foreignKeyResolver, generatedKeys, primaryKey || pk != null);
                if (!str.isEmpty()) {
                    parts.add(str);
                    parts.add(", ");
                }
                continue;
            }
            parts.add(placeholders ? "?" : getColumnName(component, columnNameResolver));
            parts.add(", ");
        }
        if (!parts.isEmpty()) {
            parts.removeLast();
        }
        return java.lang.String.join("", parts);
    }

    private static String getBindVarsStringForSet(@Nonnull Class<? extends Record> recordType,
                                                  @Nonnull String alias,
                                                  @Nullable ColumnNameResolver columnNameResolver,
                                                  @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        return getNamesForSet(recordType, alias, null, null, columnNameResolver, foreignKeyResolver).stream()
                .map(name -> STR."\{name} = ?")
                .collect(joining(", "));
    }

    @SuppressWarnings("unchecked")
    private static List<String> getNamesForSet(@Nonnull Class<? extends Record> recordType,
                                               @Nonnull String alias,
                                               @Nullable String fkName,
                                               @Nullable Class<? extends Record> fkClass,
                                               @Nullable ColumnNameResolver columnNameResolver,
                                               @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        var names = new ArrayList<String>();
        for (var component : recordType.getRecordComponents()) {
            Persist persist = REFLECTION.getAnnotation(component, Persist.class);
            if (persist != null && !persist.updatable()) {
                continue;
            }
            var converter = getORMConverter(component).orElse(null);
            if (converter != null) {
                converter.getColumns(c -> getColumnName(c, columnNameResolver))
                        .forEach(name -> names.add(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{name}"));
                continue;
            }
            if (Lazy.class.isAssignableFrom(component.getType())) {
                if (!REFLECTION.isAnnotationPresent(component, FK.class)) {
                    throw new SqlTemplateException(STR."Lazy component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is not a foreign key.");
                }
                names.add(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getForeignKey(component, foreignKeyResolver)}");
                continue;
            }
            if (fkClass != null) {
                if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                    names.add(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{fkName != null ? fkName : getColumnName(component, columnNameResolver)}");
                    // We found the PK for the foreign key. We can now return.
                    break;
                }
                if (component.getType().isRecord()) {
                    // @Inline is implicitly assumed.
                    var pks = getNamesForSet(recordType, alias, fkName, fkClass, columnNameResolver, foreignKeyResolver);
                    if (!pks.isEmpty()) {
                        names.addAll(pks);
                        // We found the PK for the foreign key. We can now return.
                        break;
                    }
                }
            } else {
                PK pk = REFLECTION.getAnnotation(component, PK.class);
                if (pk != null) {
                    continue;
                }
                if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                    names.addAll(getNamesForSet(recordType, alias, getForeignKey(component, foreignKeyResolver), (Class<? extends Record>) component.getType(), columnNameResolver, foreignKeyResolver));
                    continue;
                }
                if (component.getType().isRecord()) {
                    // @Inline is implicitly assumed.
                    names.addAll(getNamesForSet((Class<? extends Record>) component.getType(), alias, getForeignKey(component, foreignKeyResolver), fkClass, columnNameResolver, foreignKeyResolver));
                    continue;
                }
                names.add(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}");
            }
        }
        return names;
    }

    private static Map<String, Object> getValuesForSet(@Nullable Record record,
                                                       @Nonnull String alias,
                                                       @Nullable ColumnNameResolver columnNameResolver,
                                                       @Nullable ForeignKeyResolver foreignKeyResolver,
                                                       @Nonnull AtomicBoolean versionAware) throws SqlTemplateException {
        return getValuesForSet(record, alias,  null, null, columnNameResolver, foreignKeyResolver, versionAware);
    }

    private static Map<String, Object> getValuesForSet(@Nullable Record record,
                                                       @Nonnull String alias,
                                                       @Nullable String fkName,
                                                       @Nullable Class<? extends Record> fkClass,
                                                       @Nullable ColumnNameResolver columnNameResolver,
                                                       @Nullable ForeignKeyResolver foreignKeyResolver,
                                                       @Nonnull AtomicBoolean versionAware) throws SqlTemplateException {
        try {
            var values = new LinkedHashMap<String, Object>();
            if (record == null) {
                assert fkName != null;
                values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{fkName}", null);
                return values;
            }
            for (var component : record.getClass().getRecordComponents()) {
                Persist persist = REFLECTION.getAnnotation(component, Persist.class);
                if (persist != null && !persist.updatable()) {
                    continue;
                }
                var converter = getORMConverter(component).orElse(null);
                if (converter != null) {
                    values.putAll(converter.getValues(record, c -> getColumnName(c, columnNameResolver)));
                    continue;
                }
                if (Lazy.class.isAssignableFrom(component.getType())) {
                    if (!REFLECTION.isAnnotationPresent(component, FK.class)) {
                        throw new SqlTemplateException(STR."Lazy component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is not a foreign key.");
                    }
                    Lazy<?, ?> lazy = (Lazy<?, ?>) REFLECTION.invokeComponent(component, record);
                    var id = lazy == null ? null : lazy.id();
                    if (id == null && REFLECTION.isNonnull(component)) {
                        throw new SqlTemplateException(STR."Nonnull Lazy component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                    }
                    values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getForeignKey(component, foreignKeyResolver)}", id);
                    continue;
                }
                if (fkClass != null) {
                    if (component.getType().isRecord() && !REFLECTION.isAnnotationPresent(component, PK.class)) {
                        // @Inline is implicitly assumed.
                        var r = (Record) REFLECTION.invokeComponent(component, record);
                        if (r == null) {
                            // Skipping; We're only interested in finding a PK.
                            continue;
                        }
                        var pks = getValuesForSet(r, alias, fkName, fkClass, columnNameResolver, foreignKeyResolver, versionAware);
                        if (!pks.isEmpty()) {
                            values.putAll(pks);
                            // We found the PK for the foreign key. We can now return.
                            break;
                        }
                    }
                    if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                        var v = REFLECTION.invokeComponent(component, record);
                        if (v == null && REFLECTION.isNonnull(component)) {
                            throw new SqlTemplateException(STR."Primary key component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                        }
                        values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{fkName != null ? fkName : getColumnName(component, columnNameResolver)}", v);
                        // We found the PK for the foreign key. We can now return.
                        break;
                    }
                } else {
                    PK pk = REFLECTION.getAnnotation(component, PK.class);
                    if (pk != null) {
                        continue;
                    }
                    if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                        var r = (Record) REFLECTION.invokeComponent(component, record);
                        if (r == null && REFLECTION.isNonnull(component)) {
                            throw new SqlTemplateException(STR."Nonnull foreign key component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                        }
                        //noinspection unchecked
                        values.putAll(getValuesForSet(r, alias, getForeignKey(component, foreignKeyResolver), (Class<? extends Record>) component.getType(), columnNameResolver, foreignKeyResolver, versionAware));
                        continue;
                    }
                    if (REFLECTION.isAnnotationPresent(component, Version.class)) {
                        // No field will be added for version.
                        versionAware.setPlain(true);
                        continue;
                    }
                    if (component.getType().isRecord()) {
                        // @Inline is implicitly assumed.
                        var r = (Record) REFLECTION.invokeComponent(component, record);
                        if (r == null && REFLECTION.isNonnull(component)) {
                            throw new SqlTemplateException(STR."Nonnull inline component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                        }
                        //noinspection ConstantValue
                        values.putAll(getValuesForSet(r, alias, fkName, fkClass, columnNameResolver, foreignKeyResolver, versionAware));
                        continue;
                    }
                    var v = REFLECTION.invokeComponent(component, record);
                    if (v == null && REFLECTION.isNonnull(component)) {
                        throw new SqlTemplateException(STR."Nonnull component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                    }
                    values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", v);
                }
            }
            return values;
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Throwable t) {
            throw new SqlTemplateException(t);
        }
    }

    /**
     * Returns the primary key value for the specified foreign key record.
     *
     * @param record the record to retrieve the primary key value for.
     * @return the primary key value for the specified record.
     * @throws SqlTemplateException if zero or multiple primary key columns are found, or if the primary key value
     * cannot be retrieved.
     */
    private static Object getPkForForeignKey(@Nonnull Record record) throws SqlTemplateException {
        for (var component : record.getClass().getRecordComponents()) {
            if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                try {
                    Object pk = REFLECTION.invokeComponent(component, record);
                    if (pk == null) {
                        throw new SqlTemplateException(STR."Primary key value is null for \{record.getClass().getSimpleName()}.");
                    }
                    if (pk instanceof Record) {
                        throw new SqlTemplateException(STR."Foreign key specifies a compound primary key: \{record.getClass().getSimpleName()}.");
                    }
                    return pk;
                } catch (SqlTemplateException e) {
                    throw e;
                } catch (Throwable t) {
                    throw new SqlTemplateException(t);
                }
            }
        }
        throw new SqlTemplateException(STR."No primary key found for \{record.getClass().getSimpleName()}.");
    }

    private static String getBindVarsStringForWhere(@Nonnull Class<? extends Record> recordType,
                                                    @Nonnull String alias,
                                                    @Nullable ColumnNameResolver columnNameResolver) {
        return getPkNamesForWhere(recordType, alias, columnNameResolver).stream()
                .map(pkName -> STR."\{pkName} = ?")
                .collect(joining(" AND "));
    }

    private static List<String> getPkNamesForWhere(@Nonnull Class<? extends Record> recordType,
                                                   @Nonnull String alias,
                                                   @Nullable ColumnNameResolver columnNameResolver) {
        return getPkNamesForWhere(recordType, alias, columnNameResolver, false);
    }

    @SuppressWarnings("unchecked")
    private static List<String> getPkNamesForWhere(@Nonnull Class<? extends Record> recordType,
                                                   @Nonnull String alias,
                                                   @Nullable ColumnNameResolver columnNameResolver,
                                                   boolean parentPk) {
        var names = new ArrayList<String>();
        for (var component : recordType.getRecordComponents()) {
            boolean pk = REFLECTION.isAnnotationPresent(component, PK.class);
            if (component.getType().isRecord()) {
                if (getORMConverter(component).isPresent()) {
                    continue;
                }
                if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                    continue;
                }
                // @Inline is implicitly assumed.
                names.addAll(getPkNamesForWhere((Class<? extends Record>) component.getType(), alias, columnNameResolver, pk || parentPk));
            } else if (pk || parentPk) {
                names.add(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}");
            }
        }
        return names;
    }

    private static Map<String, Object> getValuesForCondition(@Nonnull Record record,
                                                             @Nullable String path,
                                                             @Nonnull Class<? extends Record> primaryTable,
                                                             @Nonnull String alias,
                                                             @Nonnull TableMapper tableMapper,
                                                             @Nullable ColumnNameResolver columnNameResolver,
                                                             @Nullable ForeignKeyResolver foreignKeyResolver,
                                                             boolean updateMode) throws SqlTemplateException {
        try {
            var values = new LinkedHashMap<String, Object>();
            if (primaryTable.isInstance(record)) {
                for (var component : record.getClass().getRecordComponents()) {
                    if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                        Object pk = REFLECTION.invokeComponent(component, record);
                        if (pk instanceof Record) {
                            values.putAll(getValuesForCondition(pk, primaryTable, alias, columnNameResolver, foreignKeyResolver));
                        } else {
                            values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", REFLECTION.invokeComponent(component, record));
                        }
                    } else if (updateMode // Only apply version check if in update mode to prevent side effects when comparing objects in other modes.
                            && REFLECTION.isAnnotationPresent(component, Version.class)) {
                        values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", REFLECTION.invokeComponent(component, record));
                    }
                }
                return values;
            }
            TableMapper.Mapping mapping = tableMapper.getMapping(record.getClass(), path);
            String a = mapping.alias();
            if (mapping.primaryKey()) {
                for (var component : mapping.components()) {
                    Object pk = REFLECTION.invokeComponent(component, record);
                    if (pk instanceof Record) {
                        values.putAll(getValuesForInlined((Record) pk, mapping.alias(), columnNameResolver));
                    } else {
                        values.put(STR."\{a.isEmpty() ? "" : STR."\{a}."}\{getColumnName(component, columnNameResolver)}", REFLECTION.invokeComponent(component, record));
                    }
                }
            } else {
                assert mapping.components().size() == 1;
                for (var component : record.getClass().getRecordComponents()) {
                    if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                        values.put(STR."\{a.isEmpty() ? "" : STR."\{a}."}\{getForeignKey(mapping.components().getFirst(), foreignKeyResolver)}", REFLECTION.invokeComponent(component, record));
                        break;  // Foreign key mappings can only be based on a single column.
                    }
                }
            }
            return values;
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Throwable t) {
            throw new SqlTemplateException(t);
        }
    }

    private static SequencedMap<String, Object> getValuesForCondition(@Nullable Object id,
                                                                      @Nonnull Class<? extends Record> recordType,
                                                                      @Nonnull String alias,
                                                                      @Nullable ColumnNameResolver columnNameResolver,
                                                                      @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        try {
            var values = new LinkedHashMap<String, Object>();
            for (var component : recordType.getRecordComponents()) {
                if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                    if (component.getType().isRecord()) {
                        if (id != null) {
                            if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                                values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getForeignKey(component, foreignKeyResolver)}", getPkForForeignKey((Record) id));
                            } else if (recordType.isInstance(id)) {
                                values.putAll(getValuesForInlined((Record) REFLECTION.invokeComponent(component, id), alias, columnNameResolver));
                            } else {
                                values.putAll(getValuesForInlined((Record) id, alias, columnNameResolver));
                            }
                        } else {
                            values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", null);
                        }
                    } else {
                        values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", id);
                    }
                    break;
                }
            }
            return values;
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Throwable t) {
            throw new SqlTemplateException(t);
        }
    }

    private static SequencedMap<String, Object> getValuesForCondition(@Nullable Object value,
                                                                      @Nonnull String path,
                                                                      @Nonnull Class<? extends Record> recordType,
                                                                      @Nonnull AliasMapper aliasMapper,
                                                                      @Nullable ColumnNameResolver columnNameResolver,
                                                                      @Nullable ForeignKeyResolver foreignKeyResolver) throws SqlTemplateException {
        return getValuesForCondition(value, path, recordType, aliasMapper, columnNameResolver, foreignKeyResolver, 0, null, 0);
    }

    private static SequencedMap<String, Object> getValuesForCondition(@Nullable Object value,
                                                                      @Nonnull String path,
                                                                      @Nonnull Class<? extends Record> recordType,
                                                                      @Nonnull AliasMapper aliasMapper,
                                                                      @Nullable ColumnNameResolver columnNameResolver,
                                                                      @Nullable ForeignKeyResolver foreignKeyResolver,
                                                                      int depth,
                                                                      @Nullable Class<? extends Record> inlineParentType,
                                                                      int inlineDepth) throws SqlTemplateException {
        assert value == null || !value.getClass().isRecord();
        try {
            var values = new LinkedHashMap<String, Object>();
            var parts = path.split("\\.");
            var components = (inlineParentType != null ? inlineParentType : recordType).getRecordComponents();
            if (parts.length == depth + 1) {
                String name = parts[depth];
                for (var component : components) {
                    if (component.getName().equals(name)) {
                        String alias = aliasMapper.getAlias(recordType, Stream.of(parts).limit(depth - inlineDepth).collect(joining(".")), INNER);
                        if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                            values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getForeignKey(component, foreignKeyResolver)}", value);
                        } else {
                            values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", value);
                        }
                        break;
                    }
                }
            } else {
                for (var component : components) {
                    if (component.getName().equals(parts[depth])) {
                        if (component.getType().isRecord()) {
                            var converter = getORMConverter(component);
                            if (converter.isPresent()) {
                                continue;
                            }
                            boolean fk = REFLECTION.isAnnotationPresent(component, FK.class);
                            Class<? extends Record> type;
                            Class<? extends Record> inlineType;
                            if (fk) {
                                //noinspection unchecked
                                type = (Class<? extends Record>) component.getType();
                                inlineType = null;
                            } else {    // Can either be PK or Inline.
                                // Assuming @Inline; No need to check for optional annotation.
                                type = recordType;
                                //noinspection unchecked
                                inlineType = (Class<? extends Record>) component.getType();
                            }
                            values.putAll(getValuesForCondition(
                                    value,
                                    path,
                                    type,
                                    aliasMapper,
                                    columnNameResolver,
                                    foreignKeyResolver,
                                    depth + 1,
                                    inlineType,
                                    inlineDepth + (inlineType != null ? 1 : 0)));
                        }
                        break;
                    }
                }
            }
            return values;
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Throwable t) {
            throw new SqlTemplateException(t);
        }
    }

    private static Map<String, Object> getValuesForInlined(@Nonnull Record record, @Nonnull String alias, @Nullable ColumnNameResolver columnNameResolver) throws SqlTemplateException {
        try {
            var values = new LinkedHashMap<String, Object>();
            for (var component : record.getClass().getRecordComponents()) {
                Object o = REFLECTION.invokeComponent(component, record);
                if (o instanceof Record r) {
                    values.putAll(getValuesForInlined(r, alias, columnNameResolver));
                } else {
                    values.put(STR."\{alias.isEmpty() ? "" : STR."\{alias}."}\{getColumnName(component, columnNameResolver)}", o);
                }
            }
            return values;
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Throwable t) {
            throw new SqlTemplateException(t);
        }
    }

    private static List<Object> getValuesForInsert(@Nonnull Record record) throws SqlTemplateException {
        return getValuesForInsert(record, record.getClass(), false);
    }

    private static List<Object> getValuesForInsert(@Nullable Record record, @Nonnull Class<? extends Record> recordClass, boolean foreignKey) throws SqlTemplateException {
        try {
            var values = new ArrayList<>();
            if (record == null && foreignKey) {
                values.add(null);
                return values;
            }
            for (var component : recordClass.getRecordComponents()) {
                Persist persist = REFLECTION.getAnnotation(component, Persist.class);
                if (persist != null && !persist.insertable()) {
                    continue;
                }
                var converter = getORMConverter(component).orElse(null);
                if (converter != null) {
                    values.addAll(converter.getValues(record));
                    continue;
                }
                if (Lazy.class.isAssignableFrom(component.getType())) {
                    if (!REFLECTION.isAnnotationPresent(component, FK.class)) {
                        throw new SqlTemplateException(STR."Lazy component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is not a foreign key.");
                    }
                    var id = record == null ? null : ((Lazy<?, ?>) REFLECTION.invokeComponent(component, record)).id();
                    if (id == null && REFLECTION.isNonnull(component)) {
                        throw new SqlTemplateException(STR."Nonnull Lazy component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                    }
                    values.add(id);
                    continue;
                }
                if (foreignKey) {
                    if (component.getType().isRecord() && !REFLECTION.isAnnotationPresent(component, FK.class)) {
                        // @Inline is implicitly assumed.
                        var r = (Record) REFLECTION.invokeComponent(component, record);
                        if (r == null) {
                            // Skipping; We're only interested in finding a PK.
                            continue;
                        }
                        var pk = getValuesForInsert(r, recordClass, true);
                        if (!pk.isEmpty()) {
                            values.add(pk);
                            // We found the PK for the foreign key. We can now return.
                            break;
                        }
                    }
                    if (REFLECTION.isAnnotationPresent(component, PK.class)) {
                        values.add(REFLECTION.invokeComponent(component, record));
                        // We found the PK for the foreign key. We can now return.
                        break;
                    }
                } else {
                    if (isAutoGenerated(component)) {
                        continue;
                    }
                    if (REFLECTION.isAnnotationPresent(component, FK.class)) {
                        var r = record == null ? null : (Record) REFLECTION.invokeComponent(component, record);
                        if (r == null && REFLECTION.isNonnull(component)) {
                            throw new SqlTemplateException(STR."Nonnull foreign key component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                        }
                        //noinspection unchecked
                        values.addAll(getValuesForInsert(r, (Class<? extends Record>) component.getType(), true));
                        continue;
                    }
                    if (component.getType().isRecord()) {
                        // @Inline is implicitly assumed.
                        var r = record == null ? null : (Record) REFLECTION.invokeComponent(component, record);
                        if (r == null && REFLECTION.isNonnull(component)) {
                            throw new SqlTemplateException(STR."Nonnull component '\{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}' is null.");
                        }
                        //noinspection unchecked
                        values.addAll(getValuesForInsert(r, (Class<? extends Record>) component.getType(), false));
                        continue;
                    }
                    values.add(record == null ? null : REFLECTION.invokeComponent(component, record));
                }
            }
            return values;
        } catch (SqlTemplateException e) {
            throw e;
        } catch (Throwable t) {
            throw new SqlTemplateException(t);
        }
    }

    private static String getAlias(@Nonnull Class<? extends Record> type,
                                   @Nullable List<RecordComponent> path,
                                   @Nonnull String alias,
                                   @Nonnull AliasMapper aliasMapper) throws SqlTemplateException {
        if (path == null) {
            var result = aliasMapper.findAlias(type, "", INNER);
            if (result.isPresent()) {
                return result.get();
            }
            if (alias.isEmpty()) {
                throw new SqlTemplateException(STR."Alias not found for \{type.getSimpleName()}");
            }
            return alias;
        }
        String p = toPathString(path);
        if (!path.isEmpty()) {
            RecordComponent lastComponent = path.getLast();
            if (REFLECTION.isAnnotationPresent(lastComponent, FK.class)) {
                return aliasMapper.getAlias(type, p, INNER);
            }
            if (REFLECTION.isAnnotationPresent(lastComponent, PK.class)) {
                return alias;
            }
            if (getORMConverter(lastComponent).isEmpty()
                    && !aliasMapper.exists(type)) { // Check needed for records without annotations.
                return alias; // @Inline is implicitly assumed.
            }
        }
        // Fallback for records without annotations.
        return aliasMapper.getAlias(type, null, INNER);
    }

    private boolean isPrimitiveCompatible(Object o, Class<?> clazz) {
        if (clazz == int.class) return o instanceof Integer;
        if (clazz == long.class) return o instanceof Long;
        if (clazz == boolean.class) return o instanceof Boolean;
        if (clazz == byte.class) return o instanceof Byte;
        if (clazz == char.class) return o instanceof Character;
        if (clazz == short.class) return o instanceof Short;
        if (clazz == float.class) return o instanceof Float;
        if (clazz == double.class) return o instanceof Double;
        return false;
    }
}
