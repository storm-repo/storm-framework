/*
 * Copyright 2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package st.orm.template.impl;

import jakarta.annotation.Nonnull;
import st.orm.DbColumn;
import st.orm.FK;
import st.orm.Lazy;
import st.orm.PK;
import st.orm.Persist;
import st.orm.PersistenceException;
import st.orm.Version;
import st.orm.spi.ORMReflection;
import st.orm.spi.Providers;
import st.orm.template.Column;
import st.orm.template.Model;
import st.orm.template.SqlTemplateException;

import java.lang.reflect.RecordComponent;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

import static st.orm.spi.Providers.getORMConverter;
import static st.orm.template.impl.RecordReflection.getColumnName;
import static st.orm.template.impl.RecordReflection.getForeignKey;
import static st.orm.template.impl.RecordReflection.getLazyRecordType;
import static st.orm.template.impl.RecordReflection.getTableName;
import static st.orm.template.impl.RecordReflection.isAutoGenerated;

/**
 * Factory for creating models.
 *
 * @since 1.2
 */
final class ModelFactory {
    private static final ConcurrentHashMap<Class<?>, Model<?, ?>> MODEL_CACHE = new ConcurrentHashMap<>();
    private static final ORMReflection REFLECTION = Providers.getORMReflection();

    private ModelFactory () {
    }

    /**
     * Creates a new instance of the model for the given builder.
     *
     * @param builder the model builder.
     * @return a new instance of the model.
     * @param <T> the record type.
     * @param <ID> the primary key type.
     * @throws SqlTemplateException if an error occurs while creating the model.
     */
    static <T extends Record, ID> Model<T, ID> create(
            @Nonnull ModelBuilderImpl builder,
            @Nonnull Class<T> type,
            boolean requirePrimaryKey) throws SqlTemplateException{
        try {
            //noinspection unchecked
            return (Model<T, ID>) MODEL_CACHE.computeIfAbsent(type, _ -> {
                AtomicInteger index = new AtomicInteger(1);
                List<Column> columns = Stream.of(type.getRecordComponents())
                        .flatMap(c -> {
                            boolean primaryKey = REFLECTION.isAnnotationPresent(c, PK.class);
                            boolean autoGenerated = primaryKey && isAutoGenerated(c);
                            return createColumns(builder, c, primaryKey, autoGenerated, false, index).stream();
                        })
                        .toList();
                try {
                    var tableName = getTableName(type, builder.tableNameResolver());
                    //noinspection unchecked
                    Class<ID> pkType = (Class<ID>) REFLECTION.findPKType(type).orElse(Void.class);
                    if (requirePrimaryKey && pkType == Void.class) {
                        throw new PersistenceException(STR."No primary key found for type: \{type.getSimpleName()}.");
                    }
                    return new ModelImpl<>(tableName, type, pkType, columns);
                } catch (SqlTemplateException e) {
                    throw new RuntimeException(e);
                }
            });
        } catch (RuntimeException e) {
            if (e.getCause() instanceof SqlTemplateException ex) {
                throw ex;
            } else {
                throw e;
            }
        }
    }

    private static List<Column> createColumns(@Nonnull ModelBuilder builder, @Nonnull RecordComponent component, boolean primaryKey, boolean autoGenerated, boolean parentNullable, @Nonnull AtomicInteger index) {
        try {
            var converter = getORMConverter(component).orElse(null);
            if (converter != null) {
                var columnTypes = converter.getParameterTypes();
                var expected = converter.getParameterCount();
                if (columnTypes.size() != expected) {
                    throw new SqlTemplateException(STR."Expected \{expected} parameter types, but got \{columnTypes.size()}.");
                }
                var columnNames = converter.getColumns(c -> RecordReflection.getColumnName(c, builder.columnNameResolver()));
                if (columnTypes.size() != columnNames.size()) {
                    throw new SqlTemplateException("Column count does not match value count.");
                }
                var columns = new ArrayList<Column>(columnTypes.size());
                for (int i = 0; i < columnTypes.size(); i++) {
                    columns.add(new ColumnImpl(columnNames.get(i), index.getAndIncrement(), columnTypes.get(i), primaryKey,
                            false, false, true, true, true, false, false));
                }
                return columns;
            }
            Class<?> componentType = component.getType();
            boolean foreignKey = REFLECTION.isAnnotationPresent(component, FK.class);
            ColumnName columnName;
            if (foreignKey) {
                columnName = getForeignKey(component, builder.foreignKeyResolver());
            } else {
                if (componentType.isRecord()) {
                    if (!primaryKey) {
                        if (REFLECTION.isAnnotationPresent(component, DbColumn.class)) {
                            // @Inline is implicitly assumed.
                            throw new SqlTemplateException(STR."DbColumn annotation is not allowed for @Inline records: \{component.getDeclaringRecord().getSimpleName()}.\{component.getName()}");
                        }
                    }
                    return Stream.of(componentType.getRecordComponents())
                            .flatMap(c -> createColumns(builder, c, primaryKey, autoGenerated, !REFLECTION.isNonnull(component), index).stream())
                            .toList();
                }
                columnName = getColumnName(component, builder.columnNameResolver());
            }
            boolean nullable = parentNullable || !REFLECTION.isNonnull(component);
            Persist persist = REFLECTION.getAnnotation(component, Persist.class);
            boolean version = REFLECTION.isAnnotationPresent(component, Version.class);
            boolean insertable = persist == null || persist.insertable();
            boolean updatable = persist == null || persist.updatable();
            boolean lazy = Lazy.class.isAssignableFrom(componentType);
            if (lazy) {
                try {
                    componentType = getLazyRecordType(component);
                } catch (SqlTemplateException e) {
                    throw new PersistenceException(e);
                }
            }
            return List.of(new ColumnImpl(columnName, index.getAndIncrement(), componentType, primaryKey, autoGenerated, foreignKey, nullable, insertable, updatable, version, lazy));
        } catch (SqlTemplateException e) {
            throw new PersistenceException(e);
        }
    }
}
